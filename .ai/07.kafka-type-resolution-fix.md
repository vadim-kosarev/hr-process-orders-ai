# Kafka Type Resolution Fix - InvalidTypeIdException

## Problem
Kafka Consumer выдавал ошибку при десериализации команд:
```
com.fasterxml.jackson.databind.exc.InvalidTypeIdException: 
Could not resolve type id 'CREATE_ORDER' as a subtype of `hr.orders.domain.command.OrderCommand`: 
known type ids = []
```

При этом в Kafka message header был:
```json
{"__TypeId__": "hr.orders.domain.command.CreateOrderCommand"}
```

## Root Cause Analysis

1. **Missing @JsonSubTypes**: Мы удалили `@JsonSubTypes` из базовых классов OrderCommand и OrderEvent
2. **Jackson lost type mapping**: Jackson больше не знал, как связать "CREATE_ORDER" с `CreateOrderCommand`  
3. **Header vs Property mismatch**: Kafka header содержит полное имя класса, но Jackson ожидал короткое имя типа
4. **JsonMessageConverter not configured**: Не было настроено сопоставление заголовков Kafka с типами Jackson

## Solution Implemented

### 1. Restored @JsonSubTypes Annotations

**OrderCommand.java:**
```java
@JsonTypeInfo(...)
@JsonSubTypes({
    @JsonSubTypes.Type(value = CreateOrderCommand.class, name = "CREATE_ORDER")
})
public abstract class OrderCommand { }
```

**OrderEvent.java:**
```java
@JsonTypeInfo(...)
@JsonSubTypes({
    @JsonSubTypes.Type(value = OrderCreatedEvent.class, name = "ORDER_CREATED"),
    @JsonSubTypes.Type(value = OrderProcessingStartedEvent.class, name = "ORDER_PROCESSING_STARTED"),
    @JsonSubTypes.Type(value = OrderProcessingFailedEvent.class, name = "ORDER_PROCESSING_FAILED"),
    @JsonSubTypes.Type(value = OrderReadyEvent.class, name = "ORDER_READY"),
    @JsonSubTypes.Type(value = OrderCancelledEvent.class, name = "ORDER_CANCELLED")
})
public abstract class OrderEvent { }
```

### 2. Enhanced JsonMessageConverter Configuration

**Consumer Configuration:**
```java
JsonMessageConverter converter = new JsonMessageConverter(objectMapper);
converter.setTypeIdHeaderName("__TypeId__");
converter.setTypeIdMappings(java.util.Map.of(
    "hr.orders.domain.command.CreateOrderCommand", "CREATE_ORDER"
));
```

**Producer Configuration:**
```java
JsonMessageConverter converter = new JsonMessageConverter(objectMapper);
converter.setTypeIdHeaderName("__TypeId__");
converter.setTypeIdMappings(java.util.Map.of(
    "hr.orders.domain.command.CreateOrderCommand", "CREATE_ORDER"
));
```

### 3. Enhanced ObjectMapper with Default Typing

```java
mapper.activateDefaultTyping(mapper.getPolymorphicTypeValidator(), 
    ObjectMapper.DefaultTyping.NON_FINAL);
```

## How It Works Now

### Serialization (Producer):
1. **KafkaTemplate** получает `CreateOrderCommand` объект
2. **JsonMessageConverter** сериализует в JSON с `commandType: "CREATE_ORDER"`
3. **Header** добавляется: `__TypeId__: "hr.orders.domain.command.CreateOrderCommand"`
4. **Сообщение отправляется в Kafka**

### Deserialization (Consumer):
1. **Kafka message** получен с header `__TypeId__`
2. **JsonMessageConverter** читает header и находит mapping: `hr.orders.domain.command.CreateOrderCommand` → `CREATE_ORDER`
3. **Jackson** использует `@JsonSubTypes` для поиска класса по имени `CREATE_ORDER`
4. **Объект десериализуется** в правильный тип `CreateOrderCommand`

## Type Resolution Strategy

### Primary Strategy: @JsonSubTypes
- Используется для команд и событий через аннотации
- Быстро и надежно

### Secondary Strategy: Kafka Headers
- Используется как fallback через `__TypeId__` header
- Поддерживает полные имена классов

### Fallback Strategy: Default Typing
- Jackson default typing для остальных объектов
- Обрабатывает вложенные объекты и value objects

## Files Modified

1. **OrderCommand.java** - восстановлена @JsonSubTypes
2. **OrderEvent.java** - восстановлена @JsonSubTypes  
3. **AppConfig.java** - добавлена конфигурация JsonMessageConverter и Default Typing

## Impact

✅ Kafka Consumer правильно десериализует команды  
✅ Поддержка как JSON property типов, так и Kafka headers  
✅ Фолбэк стратегии для максимальной совместимости  
✅ @JsonTypeName аннотации остались для консистентности  
