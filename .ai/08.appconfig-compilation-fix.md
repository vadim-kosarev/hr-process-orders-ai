# AppConfig Compilation Fix - Kafka Configuration

## Problem
Компилятор выдавал ошибку:
```
C:\...\AppConfig.java:89: error: cannot find symbol
        converter.setTypeIdHeaderName("__TypeId__");
                  ^
  symbol:   method setTypeIdHeaderName(String)
  location: variable converter of type JsonMessageConverter
```

## Root Cause
Использовался неправильный подход к настройке типизации Kafka сообщений:
- `JsonMessageConverter.setTypeIdHeaderName()` - этот метод не существует
- `JsonMessageConverter.setTypeIdMappings()` - этот метод тоже не существует

## Solution

### Правильный подход: JsonDeserializer Configuration

Вместо настройки `JsonMessageConverter`, нужно настраивать `JsonDeserializer` напрямую в `ConsumerFactory`.

### ConsumerFactory Configuration
```java
@Bean
public ConsumerFactory<String, Object> consumerFactory(ObjectMapper objectMapper) {
    var config = new HashMap<String, Object>();
    config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrap);
    config.put(ConsumerConfig.GROUP_ID_CONFIG, "order-service");
    config.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
    config.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
    
    // Правильная настройка JsonDeserializer
    config.put(JsonDeserializer.TRUSTED_PACKAGES, "hr.orders.domain.*");
    config.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
    config.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "hr.orders.domain.command.OrderCommand");
    
    return new DefaultKafkaConsumerFactory<>(config, new StringDeserializer(), 
        new JsonDeserializer<>(objectMapper));
}
```

### ProducerFactory Configuration
```java
@Bean
public ProducerFactory<String, Object> producerFactory(ObjectMapper objectMapper) {
    var config = new HashMap<String, Object>();
    config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrap);
    config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
    config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
    
    // Правильная настройка JsonSerializer
    config.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, true);
    
    return new DefaultKafkaProducerFactory<>(config, new StringSerializer(), 
        new JsonSerializer<>(objectMapper));
}
```

## Key Configuration Parameters

### Consumer (JsonDeserializer):
- **TRUSTED_PACKAGES**: `"hr.orders.domain.*"` - разрешает десериализацию наших классов
- **USE_TYPE_INFO_HEADERS**: `true` - использует заголовки типов из Kafka
- **VALUE_DEFAULT_TYPE**: `"hr.orders.domain.command.OrderCommand"` - базовый тип по умолчанию

### Producer (JsonSerializer):
- **ADD_TYPE_INFO_HEADERS**: `true` - добавляет заголовки типов в Kafka сообщения

## How It Works

### Serialization Flow (Producer):
1. `CreateOrderCommand` → JsonSerializer
2. JsonSerializer добавляет header `__TypeId__: "hr.orders.domain.command.CreateOrderCommand"`
3. Объект сериализуется в JSON с `@JsonTypeInfo` property: `"commandType": "CREATE_ORDER"`
4. Сообщение отправляется в Kafka

### Deserialization Flow (Consumer):
1. Kafka message с header `__TypeId__` → JsonDeserializer
2. JsonDeserializer читает header и понимает, что это `CreateOrderCommand`
3. Использует `@JsonSubTypes` mapping: `CREATE_ORDER` → `CreateOrderCommand.class`
4. Десериализует JSON в правильный тип объекта

## Removed Components

### Before (Incorrect):
- `JsonMessageConverter.setTypeIdHeaderName()` ❌
- `JsonMessageConverter.setTypeIdMappings()` ❌
- Лишние параметры в methods signatures

### After (Correct):
- `JsonDeserializer` configuration ✅
- `JsonSerializer` configuration ✅
- Простые method signatures

## Files Modified

1. **AppConfig.java**:
   - Исправлена `consumerFactory()` - добавлен JsonDeserializer с правильными настройками
   - Исправлена `kafkaListenerContainerFactory()` - убраны неправильные методы
   - Исправлена `producerFactory()` - добавлены настройки JsonSerializer
   - Исправлена `kafkaTemplate()` - убраны неправильные методы

## Benefits

✅ **Код компилируется** - нет ошибок компиляции  
✅ **Правильная типизация** - использует стандартные механизмы Spring Kafka  
✅ **Поддержка заголовков** - работает с Kafka type headers  
✅ **Совместимость** - совместимо с @JsonTypeInfo/@JsonSubTypes аннотациями
