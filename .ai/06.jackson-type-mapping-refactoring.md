# Jackson Type Mapping Refactoring - @JsonSubTypes to @JsonTypeName

## Summary
Переработана конфигурация типизации Jackson: вместо массивов `@JsonSubTypes` на базовых классах, используются `@JsonTypeName` аннотации на наследниках.

## Why This Approach?

### Было (Centralized @JsonSubTypes):
```java
@JsonTypeInfo(...)
@JsonSubTypes({
    @JsonSubTypes.Type(value = OrderCreatedEvent.class, name = "ORDER_CREATED"),
    @JsonSubTypes.Type(value = OrderProcessingStartedEvent.class, name = "ORDER_PROCESSING_STARTED"),
    @JsonSubTypes.Type(value = OrderProcessingFailedEvent.class, name = "ORDER_PROCESSING_FAILED"),
    @JsonSubTypes.Type(value = OrderReadyEvent.class, name = "ORDER_READY"),
    @JsonSubTypes.Type(value = OrderCancelledEvent.class, name = "ORDER_CANCELLED")
})
public abstract class OrderEvent { }
```

**Проблемы:**
- ❌ Нужно обновлять базовый класс каждый раз, когда добавляется новый подтип
- ❌ Список всех подтипов в одном месте → сложнее масштабировать
- ❌ Нарушает принцип открытости/закрытости (Open/Closed Principle)

### Стало (Decentralized @JsonTypeName):
```java
@JsonTypeInfo(...)
public abstract class OrderEvent { }

@JsonTypeName("ORDER_CREATED")
public class OrderCreatedEvent extends OrderServiceEvent { }

@JsonTypeName("ORDER_PROCESSING_STARTED")
public class OrderProcessingStartedEvent extends OrderServiceEvent { }

// ... и т.д. для каждого события
```

**Преимущества:**
- ✅ Каждый класс определяет свой тип имени
- ✅ Новые подтипы можно добавлять без изменения базового класса
- ✅ Соответствует принципу открытости/закрытости
- ✅ Ясно связан с методом `getEventType()` в коде

## Changes Made

### OrderEvent.java
- ✅ Удалена `@JsonSubTypes` аннотация
- ✅ Оставлена только `@JsonTypeInfo` на базовом классе

### OrderServiceEvent.java
- ✅ Никаких изменений (наследует @JsonTypeInfo от OrderEvent)

### Все конкретные события
- ✅ OrderCreatedEvent: добавлена `@JsonTypeName("ORDER_CREATED")`
- ✅ OrderProcessingStartedEvent: добавлена `@JsonTypeName("ORDER_PROCESSING_STARTED")`
- ✅ OrderProcessingFailedEvent: добавлена `@JsonTypeName("ORDER_PROCESSING_FAILED")`
- ✅ OrderReadyEvent: добавлена `@JsonTypeName("ORDER_READY")`
- ✅ OrderCancelledEvent: добавлена `@JsonTypeName("ORDER_CANCELLED")`

### OrderCommand.java
- ✅ Удалена `@JsonSubTypes` аннотация
- ✅ Оставлена только `@JsonTypeInfo` на базовом классе

### CreateOrderCommand.java
- ✅ Уже имеет `@JsonTypeName("CREATE_ORDER")` - не требует изменений

## How It Works

1. **Jackson читает JSON:**
   ```json
   {"eventType": "ORDER_CREATED", "orderId": "...", ...}
   ```

2. **Jackson видит `@JsonTypeInfo` на базовом классе:**
   - Смотрит на поле `eventType`
   - Пытается найти класс с `@JsonTypeName("ORDER_CREATED")`

3. **Jackson находит класс и десериализует:**
   - Создаёт экземпляр `OrderCreatedEvent`
   - Заполняет поля значениями из JSON

## Correspondence with getEventType()

Отлично соответствует существующему методу в коде:
```java
@JsonTypeName("ORDER_CREATED")          // Jackson
public class OrderCreatedEvent {
    @Override
    public String getEventType() {      // Код
        return "ORDER_CREATED";
    }
}
```

**Консистентность:** Тип в Jackson и в коде всегда совпадают!

## Benefits

| Аспект | Было | Стало |
|--------|------|-------|
| **Масштабируемость** | Нужно обновлять базовый класс | Добавляешь новый класс - всё работает |
| **Поддержка** | Централизованный список (сложнее) | Распределённое определение (проще) |
| **SOLID Принципы** | Нарушает Open/Closed Principle | Следует Open/Closed Principle |
| **Ясность** | Тип определён далеко от класса | Тип с классом в одном месте |
| **Дублирование** | `getEventType()` + `@JsonSubTypes` | `getEventType()` + `@JsonTypeName` |

## Files Modified

1. `OrderEvent.java` - удалена @JsonSubTypes
2. `OrderCommand.java` - удалена @JsonSubTypes
3. `OrderCreatedEvent.java` - добавлена @JsonTypeName
4. `OrderProcessingStartedEvent.java` - добавлена @JsonTypeName
5. `OrderProcessingFailedEvent.java` - добавлена @JsonTypeName
6. `OrderReadyEvent.java` - добавлена @JsonTypeName
7. `OrderCancelledEvent.java` - добавлена @JsonTypeName

## Backward Compatibility

✅ Полная обратная совместимость  
✅ JSON структура и поведение не изменилось  
✅ Просто код стал более масштабируемым и чистым

